import{_ as o,c as n,o as s,a as e,b as l}from"./app.586394ea.js";const A=JSON.parse('{"title":"Observer插件","description":"","frontmatter":{"title":"Observer插件"},"headers":[{"level":2,"title":"1️⃣ 配置属性","slug":"_1️⃣-配置属性","link":"#_1️⃣-配置属性","children":[{"level":3,"title":"id: {String}","slug":"id-string","link":"#id-string","children":[]},{"level":3,"title":"⭐ type: {String}","slug":"⭐-type-string","link":"#⭐-type-string","children":[]},{"level":3,"title":"axis: {String}","slug":"axis-string","link":"#axis-string","children":[]},{"level":3,"title":"⭐ lockAxis: {Boolean}","slug":"⭐-lockaxis-boolean","link":"#⭐-lockaxis-boolean","children":[]},{"level":3,"title":"onLockAxis: {Function}","slug":"onlockaxis-function","link":"#onlockaxis-function","children":[]},{"level":3,"title":"capture: {Boolean}","slug":"capture-boolean","link":"#capture-boolean","children":[]},{"level":3,"title":"debounce: {Boolean}","slug":"debounce-boolean","link":"#debounce-boolean","children":[]},{"level":3,"title":"ignore: {Element | String | Array}","slug":"ignore-element-string-array","link":"#ignore-element-string-array","children":[]},{"level":3,"title":"⭐ onChange: {Function}","slug":"⭐-onchange-function","link":"#⭐-onchange-function","children":[]},{"level":3,"title":"onChangeX: {Function}","slug":"onchangex-function","link":"#onchangex-function","children":[]},{"level":3,"title":"onChangeY: {Function}","slug":"onchangey-function","link":"#onchangey-function","children":[]},{"level":3,"title":"onClick: {Function}","slug":"onclick-function","link":"#onclick-function","children":[]},{"level":3,"title":"⭐ onDown: {Function}","slug":"⭐-ondown-function","link":"#⭐-ondown-function","children":[]},{"level":3,"title":"⭐ onUp: {Function}","slug":"⭐-onup-function","link":"#⭐-onup-function","children":[]},{"level":3,"title":"onLeft: {Function}","slug":"onleft-function","link":"#onleft-function","children":[]},{"level":3,"title":"onRight: {Function}","slug":"onright-function","link":"#onright-function","children":[]},{"level":3,"title":"onWheel: {Function}","slug":"onwheel-function","link":"#onwheel-function","children":[]},{"level":3,"title":"wheelSpeed: {Number}","slug":"wheelspeed-number","link":"#wheelspeed-number","children":[]},{"level":3,"title":"scrollSpeed: {Number}","slug":"scrollspeed-number","link":"#scrollspeed-number","children":[]},{"level":3,"title":"dragMinimum: {Number}","slug":"dragminimum-number","link":"#dragminimum-number","children":[]},{"level":3,"title":"onDragStart: {Function}","slug":"ondragstart-function","link":"#ondragstart-function","children":[]},{"level":3,"title":"⭐ onDrag: {Function}","slug":"⭐-ondrag-function","link":"#⭐-ondrag-function","children":[]},{"level":3,"title":"onDragEnd: {Function}","slug":"ondragend-function","link":"#ondragend-function","children":[]},{"level":3,"title":"onPress: {Function}","slug":"onpress-function","link":"#onpress-function","children":[]},{"level":3,"title":"onRelease: {Function}","slug":"onrelease-function","link":"#onrelease-function","children":[]},{"level":3,"title":"onHover: {Function}","slug":"onhover-function","link":"#onhover-function","children":[]},{"level":3,"title":"onHoverEnd: {Function}","slug":"onhoverend-function","link":"#onhoverend-function","children":[]},{"level":3,"title":"onMove: {Function}","slug":"onmove-function","link":"#onmove-function","children":[]},{"level":3,"title":"onStop: {Function}","slug":"onstop-function","link":"#onstop-function","children":[]},{"level":3,"title":"onStopDelay: {Number}","slug":"onstopdelay-number","link":"#onstopdelay-number","children":[]},{"level":3,"title":"⭐ onToggleX: {Function}","slug":"⭐-ontogglex-function","link":"#⭐-ontogglex-function","children":[]},{"level":3,"title":"onToggleY: {Function}","slug":"ontoggley-function","link":"#ontoggley-function","children":[]}]},{"level":2,"title":"2️⃣ 回调数据","slug":"_2️⃣-回调数据","link":"#_2️⃣-回调数据","children":[]},{"level":2,"title":"3️⃣ Observer也包含在ScrollTrigger插件中","slug":"_3️⃣-observer也包含在scrolltrigger插件中","link":"#_3️⃣-observer也包含在scrolltrigger插件中","children":[]},{"level":2,"title":"4️⃣ Observer 示例","slug":"_4️⃣-observer-示例","link":"#_4️⃣-observer-示例","children":[]}],"relativePath":"plugins/observer/index.md","lastUpdated":1676275730000}'),a={name:"plugins/observer/index.md"},c=e(`<p>超级灵活，统一化方式感知跨设备（<code>touch &amp; mouse &amp; pointer</code>） 各种事件的插件，不用再纠结实现细节🚀。</p><p>🎉有可能你想响应 <code>类滚动（scroll-like）</code> 用户行为，比如</p><ul><li>鼠标滚轮滚动</li><li>手指滑动触摸设备</li><li>滚动条拖拽</li><li>pointer点击和拖拽</li><li>方向和速度信息</li></ul><p>上面所有的这一切，都只需要告诉Observer你想观察哪个事件（<code>wheel</code>, <code>touch</code>, <code>pointer</code>, <code>scroll</code>）即可，它会在每次requestAnimationFrame tick（为了性能进行<a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noreferrer">debounced</a>）过程中收集偏移值，并且自动找出最大偏移量，然后触发合适的回调：<code>onUp</code>, <code>onDown</code>, <code>onDrag</code> 等等😎。</p><p>来看看下面例子，我们可以基于用户向上或向下或者鼠标滚轮滚动行为，十分轻松的触发 <code>next() | previous()</code> 函数：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Observer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">target</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> window</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">         </span><span style="color:#676E95;font-style:italic;">// 可以是任何元素（或者选择器）</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">wheel,touch</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;">    </span><span style="color:#676E95;font-style:italic;">// 用 \`,\` 分割你想监听的事件 \`wheel,touch,scroll,pointer\`</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">onUp</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">previouse</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">onDown</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">next</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>🌰 <a href="https://codepen.io/GreenSock/pen/XWzRraJ" target="_blank" rel="noreferrer">Animated Continuous Sections with GSAP Observer - codepen</a></p><p>注意这个例子并没有实际上的滚动，但是你可以用鼠标滚轮或者触摸设备swipe来开启动画，就好像在滚动一样😁</p>`,8),t=l("iframe",{height:"300",style:{width:"100%"},scrolling:"no",title:"Animated Continuous Sections with GSAP Observer",src:"https://codepen.io/GreenSock/embed/preview/XWzRraJ?default-tab=result&theme-id=dark",frameborder:"no",loading:"lazy",allowtransparency:"true",allowfullscreen:"true"},`
  See the Pen <a href="https://codepen.io/GreenSock/pen/XWzRraJ">
  Animated Continuous Sections with GSAP Observer</a> by GreenSock (<a href="https://codepen.io/GreenSock">@GreenSock</a>)
  on <a href="https://codepen.io">CodePen</a>.
`,-1),r=e(`<div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Observer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">type</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">wheel,touch,pointer</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">wheelSpeed</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">onDown</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">animating </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">gotoSection</span><span style="color:#A6ACCD;">(currentIndex </span><span style="color:#89DDFF;">-</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">onUp</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!</span><span style="color:#A6ACCD;">animating </span><span style="color:#89DDFF;">&amp;&amp;</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">gotoSection</span><span style="color:#A6ACCD;">(currentIndex </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">tolerance</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">preventDefault</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">true</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><p>特色功能：</p><ul><li><code>⭐ 丰富回调系统</code>： 包括 <code>onDown &amp; onUp &amp; onLeft &amp; onRight &amp; onDrag &amp; onDragStart &amp; onDragEnd &amp; onHover &amp; onHoverEnd &amp; onToggleY &amp; onToggleX &amp; onChangeX &amp; onChangeY &amp; onChange &amp; onClick &amp; onPress &amp; onRelease &amp; onMove &amp; onWheel &amp; onStop</code></li><li><code>默认debounced</code>： 性能最大化，可以通过 <code>debounce: false</code> 关闭</li><li>使用最大偏移量（<code>largest delta</code>） 自动优化事件（就好像wheel和scroll和touch事件在相同的debounced期间发生一样）</li><li>忽略特定元素，比如 <code>.ignore: &#39;.deadzone&#39;</code></li><li>获取 <strong><code>速度</code></strong> (分别对 <code>x</code> &amp; <code>y</code> 轴)，同时获取 <code>clientX</code> &amp; <code>clientY</code> 坐标系（针对 touch/pointer事件）</li><li>对 <strong><code>拖拽设置最小阈值</code></strong>，比如 <code>dragMinimum: 5</code> 只有用户移动超过 <code>5px</code> 才触发 <code>onDragStart | onDrag | onDragEnd</code> 回调</li><li>设置一个 <code>tolerance</code>，只有当最小偏移量达到时才触发动作相关（<code>movement-related</code>）的回调，比如 <code>tolerance: 50</code> ，将等到至少 <code>50px</code> 变量才触发回调，然后一旦触发再重新来过</li><li>如果你想改变滚轮相关的偏移量，设置 <code>wheelSpeed</code> 乘法系数（加速或者减速）</li><li><a href="./../scroll-trigger/index.html">ScrollTrigger</a> 插件内置了 <code>Observer</code> 插件 - <code>ScrollTrigger.observe()</code></li><li>gzip后大约 <code>3.5kb</code></li></ul><h2 id="_1️⃣-配置属性" tabindex="-1">1️⃣ 配置属性 <a class="header-anchor" href="#_1️⃣-配置属性" aria-hidden="true">#</a></h2><p>下面属性都是传入到 <code>Observer.create(var: Object)</code> 配置对象中的。</p><h3 id="id-string" tabindex="-1"><code>id: {String}</code> <a class="header-anchor" href="#id-string" aria-hidden="true">#</a></h3><p>任意字符串ID，可被 <code>Observer.getById()</code> 获取指定的 <code>Observer</code></p><h3 id="⭐-type-string" tabindex="-1"><code>⭐ type: {String}</code> <a class="header-anchor" href="#⭐-type-string" aria-hidden="true">#</a></h3><p>逗号分割的要监听的事件类型列表，可以包含 <code>&quot;wheel,touch,scroll,pointer&quot;</code> 任意一种或者几种</p><ul><li><code>&quot;touch&quot;</code> 只针对触摸设备</li><li><code>&quot;pointer&quot;</code> 覆盖任何非触摸的 <code>pointer|mouse</code> &amp; <code>press|drag|swipe</code> 动作</li><li><code>&quot;wheel&quot;</code> 针对鼠标滚轮（或者mac的触摸板滑动）</li><li><code>&quot;scroll&quot;</code> 滚动事件</li><li>默认是 <code>type: &quot;wheel,touch,pointer&quot;</code></li></ul><h3 id="axis-string" tabindex="-1"><code>axis: {String}</code> <a class="header-anchor" href="#axis-string" aria-hidden="true">#</a></h3><p>当设置了 <code>lockAxis: true</code>，每次press后的第一次拖动动作（使用 <code>type: &quot;pointer&quot;</code> |&amp; <code>&quot;touch&quot;</code>）将设置 <code>axis</code> 属性为 <code>&quot;x&quot;</code> | <code>&quot;y&quot;</code>，取决于用户移动的方向。你可以使用 <code>onLockAxis()</code> 回调获取设置的 <code>axis</code> 的值</p><h3 id="⭐-lockaxis-boolean" tabindex="-1"><code>⭐ lockAxis: {Boolean}</code> <a class="header-anchor" href="#⭐-lockaxis-boolean" aria-hidden="true">#</a></h3><p>如果设置为 <code>true</code>，Observer将在用户每次按下(type: <code>&quot;pointer&quot;</code> |&amp; <code>&quot;touch&quot;</code>)后观察第一次拖动移动的方向，并锁定在该方向，直到用户释放pointer/touch。因此，如果第一次拖动是水平的，那么只有水平相关的回调，如<code>onChangeX()</code>将被触发，直到pointer/touch被释放。还有一个 <code>onLockAxis</code> 回调你可以绑定</p><h3 id="onlockaxis-function" tabindex="-1"><code>onLockAxis: {Function}</code> <a class="header-anchor" href="#onlockaxis-function" aria-hidden="true">#</a></h3><p>当轴被锁定时调用（需要设置 <code>lockAxis: true</code>）</p><ul><li>你可以通过Observer的 <code>axis: &quot;x&quot;</code> | <code>axis: &quot;y&quot;</code> 检测指定的轴</li></ul><h3 id="capture-boolean" tabindex="-1"><code>capture: {Boolean}</code> <a class="header-anchor" href="#capture-boolean" aria-hidden="true">#</a></h3><p>如果设置为 <code>true</code>，则 <code>touch|pointer</code> 相关的监听函数将使用捕获阶段，好像 <code>addEventListener(&#39;[type]&#39;, func, { capture: true })</code> 一样</p><h3 id="debounce-boolean" tabindex="-1"><code>debounce: {Boolean}</code> <a class="header-anchor" href="#debounce-boolean" aria-hidden="true">#</a></h3><p>默认情况，Observer会debounce事件，因此deltas会在每次requestAnimationFramer()过程中进行累加，以最大化性能，但你可以使用 <code>debounce: false</code> 禁用这个，这样每个事件都会立刻检测。</p><ul><li><code>onPress</code> &amp; <code>onRelease</code> &amp; <code>onHover</code> &amp; <code>onHoverEnd</code> &amp; <code>onClick</code> &amp; <code>onDragStart</code> &amp; <code>onDragEnd</code> 这些和delta不相关的事件，不会受到这个属性的影响😁</li></ul><h3 id="ignore-element-string-array" tabindex="-1"><code>ignore: {Element | String | Array}</code> <a class="header-anchor" href="#ignore-element-string-array" aria-hidden="true">#</a></h3><p>被 <code>忽略</code> 观察的元素，因此，当一个<code>滚动/触摸/指针/鼠标</code>事件被这些元素触发时，它会被完全忽略。</p><p>它会检测 <code>event.target</code> 来分辨是否事件应该被忽略。可以定义元素，选择器或者元素数组</p><h3 id="⭐-onchange-function" tabindex="-1"><code>⭐ onChange: {Function}</code> <a class="header-anchor" href="#⭐-onchange-function" aria-hidden="true">#</a></h3><p>存在垂直（<code>y-axis</code>） 或者 水平（<code>x-axis</code>） 动作就会触发这个回调。只要移动继续，它就会继续调用函数(受制于任何 <code>tolerance</code> 阈值)</p><h3 id="onchangex-function" tabindex="-1"><code>onChangeX: {Function}</code> <a class="header-anchor" href="#onchangex-function" aria-hidden="true">#</a></h3><p>水平方向（<code>x-axis</code>） 动作就会触发这个回调。只要移动继续，它就会继续调用函数(受制于任何 <code>tolerance</code> 阈值)</p><h3 id="onchangey-function" tabindex="-1"><code>onChangeY: {Function}</code> <a class="header-anchor" href="#onchangey-function" aria-hidden="true">#</a></h3><p>垂直方向（<code>y-axis</code>） 动作就会触发这个回调。只要移动继续，它就会继续调用函数(受制于任何 <code>tolerance</code> 阈值)</p><h3 id="onclick-function" tabindex="-1"><code>onClick: {Function}</code> <a class="header-anchor" href="#onclick-function" aria-hidden="true">#</a></h3><p>当目标被点击时触发</p><h3 id="⭐-ondown-function" tabindex="-1"><code>⭐ onDown: {Function}</code> <a class="header-anchor" href="#⭐-ondown-function" aria-hidden="true">#</a></h3><p>向下（<code>DOWNWARD</code>）动作被检测到时，调用这个函数，意味着delta值增加（就好像你 <code>向下</code> 拖动手指或者鼠标，这会使 <code>y</code> 坐标增加📚）。如果你只想反向鼠标滚轮delta，你可以设置 <code>wheelSpeed: -1</code>， 它是一个乘法系数</p><h3 id="⭐-onup-function" tabindex="-1"><code>⭐ onUp: {Function}</code> <a class="header-anchor" href="#⭐-onup-function" aria-hidden="true">#</a></h3><p>向上（<code>UPWARD</code>）动作被检测到时，调用这个函数，意味着delta值减少（就好像你 <code>向上</code> 拖动手指或者鼠标，这会使 <code>y</code> 坐标减少📚）。如果你只想反向鼠标滚轮delta，你可以设置 <code>wheelSpeed: -1</code>， 它是一个乘法系数</p><h3 id="onleft-function" tabindex="-1"><code>onLeft: {Function}</code> <a class="header-anchor" href="#onleft-function" aria-hidden="true">#</a></h3><p>当动作被检测到向左移动时，调用这个函数</p><h3 id="onright-function" tabindex="-1"><code>onRight: {Function}</code> <a class="header-anchor" href="#onright-function" aria-hidden="true">#</a></h3><p>当动作被检测到向右移动时，调用这个函数</p><h3 id="onwheel-function" tabindex="-1"><code>onWheel: {Function}</code> <a class="header-anchor" href="#onwheel-function" aria-hidden="true">#</a></h3><p>移动鼠标滚动时触发此回调</p><h3 id="wheelspeed-number" tabindex="-1"><code>wheelSpeed: {Number}</code> <a class="header-anchor" href="#wheelspeed-number" aria-hidden="true">#</a></h3><p>滚轮滚动delta的乘法系数。默认情况下，它只是传递浏览器报告的滚轮事件的增量，但可能它看起来比用指针 press|drag 时更快/更慢，你需要一种方法使它们更相似。</p><ul><li><code>wheelSpeed: 0.5</code> 表示使滚轮的delta值为正常值的一半</li><li><code>wheelSpeed: -1</code> 反转delta值，即本该调用 <code>onUp</code> 的，会去调用 <code>onDown</code> 回调，反之亦然</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>还有一个 <code>scrollSpeed</code> 选项只应用于 <code>scroll</code> 事件</p></div><h3 id="scrollspeed-number" tabindex="-1"><code>scrollSpeed: {Number}</code> <a class="header-anchor" href="#scrollspeed-number" aria-hidden="true">#</a></h3><p>滚动delta值的乘法系数。</p><ul><li>只应用于 <code>scroll</code> 事件，不同于 <code>wheel</code> 事件</li><li><code>scrollSpeed: -1</code> 反转delta值，即本该调用 <code>onUp</code> 的，会去调用 <code>onDown</code> 回调，反之亦然</li><li><code>scrollSpeed: 0.5</code> 表示使滚动的delta值为正常值的一半</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>还有一个 <code>wheelSpeed</code> 选项只应用于 <code>wheel</code> 事件</p></div><h3 id="dragminimum-number" tabindex="-1"><code>dragMinimum: {Number}</code> <a class="header-anchor" href="#dragminimum-number" aria-hidden="true">#</a></h3><p>被认定为 <code>drag</code> 动作的最小距离，单位 <code>px</code>。这可以阻止不小心微小的动作（特别是touch设备）。比如，用户按压了手机，不小心移动了几像素，但用户并不认为是拖动操作。<code>dragMinimum</code> 只应用于按压后的初始动作，但在此之后继续拖拽只能受制于 <code>tolerance</code> 节流。</p><h3 id="ondragstart-function" tabindex="-1"><code>onDragStart: {Function}</code> <a class="header-anchor" href="#ondragstart-function" aria-hidden="true">#</a></h3><p>当用户按压目标，开始拖动时调用这个函数（受限于 <code>dragMinimum</code>）</p><ul><li>这只适用于 <code>touch</code> &amp;| <code>pointer</code> 类型事件</li></ul><h3 id="⭐-ondrag-function" tabindex="-1"><code>⭐ onDrag: {Function}</code> <a class="header-anchor" href="#⭐-ondrag-function" aria-hidden="true">#</a></h3><p>当用户一直按压目标元素移动 <code>pointer | touch | mouse</code> 时触发</p><ul><li>这只适用于 <code>touch</code> &amp;| <code>pointer</code> 类型事件</li></ul><h3 id="ondragend-function" tabindex="-1"><code>onDragEnd: {Function}</code> <a class="header-anchor" href="#ondragend-function" aria-hidden="true">#</a></h3><p>用户停止拖动目标元素时调用调用</p><ul><li>这只适用于 <code>touch</code> &amp;| <code>pointer</code> 类型事件</li></ul><h3 id="onpress-function" tabindex="-1"><code>onPress: {Function}</code> <a class="header-anchor" href="#onpress-function" aria-hidden="true">#</a></h3><p>当用户按压目标元素时调用</p><ul><li>这只适用于 <code>touch</code> &amp;| <code>pointer</code> 类型事件</li></ul><h3 id="onrelease-function" tabindex="-1"><code>onRelease: {Function}</code> <a class="header-anchor" href="#onrelease-function" aria-hidden="true">#</a></h3><p>当 pointer|mouse释放时调用，它在 <code>onPress</code> 之后调用</p><ul><li>这只适用于 <code>touch</code> &amp;| <code>pointer</code> 类型事件</li></ul><h3 id="onhover-function" tabindex="-1"><code>onHover: {Function}</code> <a class="header-anchor" href="#onhover-function" aria-hidden="true">#</a></h3><p>当pointer或mouse移动在目标元素上时调用</p><ul><li><code>pointerenter</code> | <code>mouseenter</code> 事件</li></ul><h3 id="onhoverend-function" tabindex="-1"><code>onHoverEnd: {Function}</code> <a class="header-anchor" href="#onhoverend-function" aria-hidden="true">#</a></h3><p>当pointer或mouse移处目标元素上时调用</p><ul><li><code>pointerleave</code> | <code>mouseleave</code> 事件</li></ul><h3 id="onmove-function" tabindex="-1"><code>onMove: {Function}</code> <a class="header-anchor" href="#onmove-function" aria-hidden="true">#</a></h3><p>当用户将鼠标悬停在目标元素上时移动指针/鼠标时调用的函数(仅适用于 <code>pointer</code> 类型)。</p><ul><li>它内部监听 <code>pointermove | mousemove</code> 事件</li><li>如果你想只在 按压然后拖动 触发事件，请使用 <code>onDrag</code> 回调</li></ul><p>注意，当你定义onMove时，它会使Observer在悬停在目标上时测量增量值，从而触发适当的移动相关回调，比如 <code>onUp</code>, <code>onDown</code>, <code>onChange</code> 等，对于任何指针/鼠标在目标上的移动。</p><p>正常情况下，移动相关的回调只在用户 <strong><code>按压且拖动</code></strong> 情况下触发。</p><h3 id="onstop-function" tabindex="-1"><code>onStop: {Function}</code> <a class="header-anchor" href="#onstop-function" aria-hidden="true">#</a></h3><p>当至少停止 <code>0.25s</code> 后调用（可配置 <code>onStopDelay</code>）</p><h3 id="onstopdelay-number" tabindex="-1"><code>onStopDelay: {Number}</code> <a class="header-anchor" href="#onstopdelay-number" aria-hidden="true">#</a></h3><p>配置停止后多长时间调用 <code>onStop</code> 回调</p><ul><li>默认 <code>0.25s</code></li></ul><h3 id="⭐-ontogglex-function" tabindex="-1"><code>⭐ onToggleX: {Function}</code> <a class="header-anchor" href="#⭐-ontogglex-function" aria-hidden="true">#</a></h3><p>当运动在X轴方向（水平）<code>转变方向</code>时调用</p><h3 id="ontoggley-function" tabindex="-1"><code>onToggleY: {Function}</code> <a class="header-anchor" href="#ontoggley-function" aria-hidden="true">#</a></h3><p>当运动在Y轴方向（垂直）<code>转变方向</code>时调用</p><h2 id="_2️⃣-回调数据" tabindex="-1">2️⃣ 回调数据 <a class="header-anchor" href="#_2️⃣-回调数据" aria-hidden="true">#</a></h2><p>每个回调都将Observer实例作为唯一参数进行传递，因此你可以很轻松的访问到 <code>self.velocityX</code> &amp; <code>self.velocityY</code> &amp; <code>self.deltaX</code> &amp; <code>self.deltaY</code> &amp; <code>self.x</code> &amp; <code>self.y</code> 等等，具体属性可以查看 插件属性。</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Observer</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#82AAFF;">onChange</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">self</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">velocity: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">velocityX</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">velocityY</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">delta: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">deltaX</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">deltaY</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">target element: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">target</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">last event: </span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">event</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><h2 id="_3️⃣-observer也包含在scrolltrigger插件中" tabindex="-1">3️⃣ Observer也包含在ScrollTrigger插件中 <a class="header-anchor" href="#_3️⃣-observer也包含在scrolltrigger插件中" aria-hidden="true">#</a></h2><p>📚<code>ScrollTrigger.observe()</code> 方法等价于 <code>Observer.create()</code>。因为ScrollTrigger的 <a href="https://greensock.com/docs/v3/Plugins/ScrollTrigger/static.normalizeScroll()" target="_blank" rel="noreferrer">normalizeScroll()</a> 功能底层利用了Observer，避免使用ScrollTrigger的项目中，避免重复加载Observer插件，因此在ScrollTrigger中暴露Observer功能就很合理。</p><h2 id="_4️⃣-observer-示例" tabindex="-1">4️⃣ Observer 示例 <a class="header-anchor" href="#_4️⃣-observer-示例" aria-hidden="true">#</a></h2><ul><li><a href="https://codepen.io/collection/KpNYOd" target="_blank" rel="noreferrer">Observer demos - GreenSock@codepen</a></li></ul><p>2022年11月03日17:31:59</p>`,96),p=[c,t,r];function d(i,u,h,y,D,F){return s(),n("div",null,p)}const C=o(a,[["render",d]]);export{A as __pageData,C as default};
